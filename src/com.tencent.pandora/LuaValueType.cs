using System;

namespace com.tencent.pandora
{
	internal class LuaValueType : LuaObject
	{
		private static string script = "\r\nif not UnityEngine or not UnityEngine.Vector2 then\r\n    print('No static code gen yet, ignore `LuaValueType:reg` !!! ')\r\n    return\r\nend\r\nlocal setmetatable=setmetatable\r\nlocal getmetatable=getmetatable\r\nlocal type=type\r\nlocal clamp=clamp\r\nlocal acos=math.acos\r\nlocal sin=math.sin\r\nlocal cos=math.cos\r\nlocal sqrt=math.sqrt\r\nlocal error=error\r\nlocal min=math.min\r\nlocal max=math.max\r\nlocal abs=math.abs\r\nlocal pow=math.pow\r\nlocal Time=UnityEngine.Time\r\n\r\nlocal ToAngle=57.29578\r\nlocal ToRad=0.01745329\r\nlocal Epsilon=0.00001\r\nlocal Infinite=1/0\r\nlocal Sqrt2=0.7071067811865475244008443621048490\r\nlocal PI=3.14159265358979323846264338327950\r\n\r\nlocal function clamp(v,min,max)\r\n\tmin = min or 0\r\n\tmax = max or 1\r\n\treturn v>max and max or (v<min and min or v)\r\nend\r\n\r\nlocal function  lerpf(a,b,t)\r\n\tt=clamp(t,0,1)\r\n\treturn a+(b-a)*t\r\nend\r\n\r\nlocal function inherite(cls,base)\r\n\tfor k,v in pairs(getmetatable(base)) do\r\n\t\tif k:sub(1,2)~='__' and  k:sub(1,1)>='A' and k:sub(1,1)<='Z' then\r\n\t\t\tcls[k]=v\r\n\t\tend\r\n\tend\r\nend\r\n\r\nlocal Matrix3x3={}\r\nlocal Vector3\r\n\r\ndo\r\n\r\n\tfunction Matrix3x3.SetAt(m,row,col,v)\r\n\t\tm[row*3+col+1]=v\r\n\tend\r\n\r\n\tfunction Matrix3x3.New()\r\n\t\tlocal r={1,0,0,0,1,0,0,0,1}\r\n\t\tsetmetatable(r,Matrix3x3)\r\n\t\treturn r\r\n\tend\r\n\r\n\tfunction Matrix3x3.__tostring(m)\r\n\t\treturn string.format('Matrix3x3(%f,%f,%f,%f,%f,%f,%f,%f,%f)'\r\n\t\t\t,m[1],m[2],m[3]\r\n\t\t\t,m[4],m[5],m[6]\r\n\t\t\t,m[7],m[8],m[9])\r\n\tend\r\n\r\n\tfunction Matrix3x3.SetAxisAngle(m,axis,rad)\r\n\t\t-- This function contributed by Erich Boleyn (erich@uruk.org) */\r\n\t\t-- This function used from the Mesa OpenGL code (matrix.c)  */\r\n\t\tlocal s, c\r\n\t\tlocal vx, vy, vz, xx, yy, zz, xy, yz, zx, xs, ys, zs, one_c\r\n\r\n\t\ts = sin (rad)\r\n\t\tc = cos (rad)\r\n\r\n\t\tvx = axis[1]\r\n\t\tvy = axis[2]\r\n\t\tvz = axis[3]\r\n\r\n\t\txx = vx * vx\r\n\t\tyy = vy * vy\r\n\t\tzz = vz * vz\r\n\t\txy = vx * vy\r\n\t\tyz = vy * vz\r\n\t\tzx = vz * vx\r\n\t\txs = vx * s\r\n\t\tys = vy * s\r\n\t\tzs = vz * s\r\n\t\tone_c = 1.0 - c\r\n\t\tlocal Set=Matrix3x3.SetAt\r\n\t\tSet(m,0,0, (one_c * xx) + c )\r\n\t\tSet(m,1,0, (one_c * xy) - zs)\r\n\t\tSet(m,2,0, (one_c * zx) + ys)\r\n\t\tSet(m,0,1, (one_c * xy) + zs)\r\n\t\tSet(m,1,1, (one_c * yy) + c )\r\n\t\tSet(m,2,1, (one_c * yz) - xs)\r\n\t\tSet(m,0,2, (one_c * zx) - ys)\r\n\t\tSet(m,1,2, (one_c * yz) + xs)\r\n\t\tSet(m,2,2, (one_c * zz) + c )\r\n\tend\r\n\r\n\tfunction Matrix3x3.Mul(m,v)\r\n\t\tlocal res=Vector3.New(0,0,0)\r\n\t\tres[1] = m[1] * v[1] + m[4] * v[2] + m[7] * v[3]\r\n\t\tres[2] = m[2] * v[1] + m[5] * v[2] + m[8] * v[3]\r\n\t\tres[3] = m[3] * v[1] + m[6] * v[2] + m[9] * v[3]\r\n\t\treturn res\r\n\tend\r\n\r\n\tfunction Matrix3x3:SetIdentity()\r\n\t\tself[1],self[2],self[3]=1,0,0\r\n\t\tself[4],self[5],self[6]=0,1,0\r\n\t\tself[7],self[8],self[9]=0,0,1\r\n\tend\r\n\r\n\tfunction Matrix3x3:SetOrthoNormal( x,y,z )\r\n\t\tself[1],self[2],self[3]=x[1],y[1],z[1]\r\n\t\tself[4],self[5],self[6]=x[2],y[2],z[2]\r\n\t\tself[7],self[8],self[9]=x[3],y[3],z[3]\r\n\tend\r\nend\r\n\r\ndo\r\n\tlocal Raw=UnityEngine.Vector3\r\n\tVector3={__typename='Vector3',__raw=Raw}\r\n\tlocal T=Vector3\r\n\tlocal I={__typename='Vector3'}\r\n\t_G['UnityEngine.Vector3.Instance']=I\r\n\tUnityEngine.Vector3=Vector3\r\n\tlocal get={}\r\n\tlocal set={}\r\n\r\n\tVector3.__index = function(t,k)\r\n\t\tlocal f=rawget(Vector3,k)\r\n\t\tif f then return f end\r\n\t\tlocal f=rawget(get,k)\r\n\t\tif f then return f(t) end\r\n\t\terror('Not found '..k)\r\n\tend\r\n\r\n\tVector3.__newindex = function(t,k,v)\r\n\t\tlocal f=rawget(set,k)\r\n\t\tif f then return f(t,v) end\r\n\t\terror('Not found '..k)\r\n\tend\r\n\r\n\r\n\tVector3.New=function (x,y,z)\r\n\t\tlocal v={x or 0,y or 0,z or 0}\r\n\t\tsetmetatable(v,I)\r\n\t\treturn v\r\n\tend\r\n\r\n\tVector3.__call = function(t,x,y,z)\r\n\t\treturn Vector3.New(x,y,z)\r\n\tend\r\n\r\n\tI.__index = function(t,k)\r\n\t\tlocal f=rawget(I,k)\r\n\t\tif f then return f end\r\n\t\tlocal f=rawget(get,k)\r\n\t\tif f then return f(t) end\r\n\t\terror('Not found '..k)\r\n\tend\r\n\r\n\tI.__newindex = function(t,k,v)\r\n\t\tlocal f=rawget(set,k)\r\n\t\tif f then return f(t,v) end\r\n\t\terror('Not found '..k)\r\n\tend\r\n\r\n\tI.__eq = function(a,b)\r\n\t\treturn abs(a[1]-b[1])<Epsilon\r\n\t\t \tand abs(a[2]-b[2])<Epsilon\r\n\t\t \tand abs(a[3]-b[3])<Epsilon\r\n\tend\r\n\r\n\tI.__unm = function(a)\r\n\t\tlocal ca=Vector3.New(-a[1],-a[2],-a[3])\r\n\t\treturn ca\r\n\tend\r\n\r\n\r\n\tI.__tostring = function(self)\r\n\t\treturn string.format('Vector3(%f,%f,%f)',self[1],self[2],self[3])\r\n\tend\r\n\r\n\tI.__mul = function(a,b)\r\n\t\tlocal ta=type(a)\r\n\t\tlocal tb=type(b)\r\n\t\tif ta=='table' and tb=='number' then\r\n\t\t\treturn Vector3.New(a[1]*b,a[2]*b,a[3]*b)\r\n\t\telseif ta=='number' and tb=='table' then\r\n\t\t\treturn Vector3.New(a*b[1],a*b[2],a*b[3])\r\n\t\telse\r\n\t\t\terror(string.format('unexpect type of arguments, got %s,%s',ta,tb))\r\n\t\tend\r\n\tend\r\n\r\n\tI.__add = function(a,b)\r\n\t\treturn Vector3.New(a[1]+b[1],a[2]+b[2],a[3]+b[3])\r\n\tend\r\n\r\n\tI.__sub = function(a,b)\r\n\t\treturn Vector3.New(a[1]-b[1],a[2]-b[2],a[3]-b[3])\r\n\tend\r\n\r\n\tI.__div = function(a,b)\r\n\t\treturn Vector3.New(a[1]/b,a[2]/b,a[3]/b)\r\n\tend\r\n\r\n\tfunction Vector3.Mul(self,b)\r\n\t\tself[1],self[2],self[3]=self[1]*b,self[2]*b,self[3]*b\r\n\tend\r\n\r\n\tfunction Vector3.Add(self,b)\r\n\t\tself[1],self[2],self[3]=self[1]+b[1],self[2]+b[2],self[3]+b[3]\r\n\tend\r\n\r\n\tfunction Vector3.Sub(self,b)\r\n\t\tself[1],self[2],self[3]=self[1]-b[1],self[2]-b[2],self[3]-b[3]\r\n\tend\r\n\r\n\tfunction Vector3.Div(self,b)\r\n\t\tself[1],self[2],self[3]=self[1]/b,self[2]/b,self[3]/b\r\n\tend\r\n\r\n\r\n\tfunction get.back() return Vector3.New(0,0,-1) end\r\n\tfunction get.down() return Vector3.New(0,-1,0) end\r\n\tfunction get.forward() return Vector3.New(0,0,1) end\r\n\tfunction get.left() return Vector3.New(-1,0,0) end\r\n\tfunction get.one() return Vector3.New(1,1,1) end\r\n\tfunction get.right() return Vector3.New(1,0,0) end\r\n\tfunction get.up() return Vector3.New(0,1,0) end\r\n\tfunction get.zero() return Vector3.New(0,0,0) end\r\n\r\n\tfunction get:x() return self[1] end\r\n\tfunction get:y() return self[2] end\r\n\tfunction get:z() return self[3] end\r\n\tfunction set:x(v) self[1]=v end\r\n\tfunction set:y(v) self[2]=v end\r\n\tfunction set:z(v) self[3]=v end\r\n\tfunction get:magnitude() return Vector3.Magnitude(self) end\r\n\tfunction get:sqrMagnitude() return Vector3.SqrMagnitude(self) end\r\n\tfunction get:normalized() \r\n\t\treturn Vector3.Normalize(self)\r\n\tend\r\n\r\n\r\n\tfunction Vector3:Clone()\r\n\t\treturn Vector3.New(self[1],self[2],self[3])\r\n\tend\r\n\t\t\r\n\tfunction I:Set(x,y,z)\t\r\n\t\tself[1],self[2],self[3]=x or 0,y or 0,z or 0\r\n\tend\r\n\r\n\tfunction I:ToString()\r\n\t\treturn self:__tostring()\r\n\tend\r\n\r\n\tfunction Vector3.Angle(a,b)\r\n\t\tlocal dot = Vector3.Dot(Vector3.Normalize(a), Vector3.Normalize(b))\r\n\t\treturn acos(dot)*ToAngle\r\n\tend\r\n\r\n\tfunction Vector3.Normalized(v)\r\n\t\tlocal m = Vector3.Magnitude(v)\r\n\t\tif m==1 then\r\n\t\t\treturn v\r\n\t\telseif m>Epsilon then\r\n\t\t\tv[1],v[2],v[3]=v[1]/m,v[2]/m,v[3]/m\r\n\t\telse\r\n\t\t\tv:Set(0,0,0)\r\n\t\tend\r\n\tend\r\n\r\n    function Vector3.Normalize(v)\r\n        local v=Vector3.Clone(v)\r\n        Vector3.Normalized(v)\r\n        return v\r\n\tend\r\n\r\n\tfunction I:Normalize()\r\n\t\tVector3.Normalized(self)\r\n\tend\r\n\r\n\tfunction Vector3.Magnitude(v)\r\n\t\tlocal v= sqrt(v[1]^2+v[2]^2+v[3]^2)\r\n\t\treturn v\r\n\tend\r\n\r\n\tfunction Vector3.SqrMagnitude(v)\r\n\t\tlocal v= v[1]^2+v[2]^2+v[3]^2\r\n\t\treturn v\r\n\tend\r\n\r\n\tfunction Vector3.Dot(a,b)\r\n\t\tlocal v= a[1]*b[1] + a[2]*b[2] + a[3]*b[3]\r\n\t\treturn v\r\n\tend\r\n\r\n\tfunction Vector3.Cross(a,b)\r\n\t\treturn Vector3.New((a[2] * b[3]) - (a[3] * b[2])\r\n\t\t\t, (a[3] * b[1]) - (a[1] * b[3])\r\n\t\t\t, (a[1] * b[2]) - (a[2] * b[1]))\r\n\tend\r\n\r\n\tfunction Vector3.OrthoNormalVector(n)\r\n\t\tlocal res=Vector3.New(0,0,0)\r\n\t\tif abs(n[3]) > Sqrt2 then\r\n\t\t\tlocal a = n[2]^2 + n[3]^2\r\n\t\t\tlocal k = 1 / sqrt (a)\r\n\t\t\tres[1],res[2],res[3] = 0,-n[3]*k,n[2]*k\r\n\t\telse\r\n\t\t\tlocal a = n[1]^2 + n[2]^2\r\n\t\t\tlocal k = 1 / sqrt (a)\r\n\t\t\tres[1],res[2],res[3] = -n[2]*k,n[1]*k,0\r\n\t\tend\r\n\t\treturn res\r\n\tend\r\n\r\n\tfunction Vector3.Slerp(a,b,t)\r\n\t\tif t<=0 then return Vector3.Clone(a) end\r\n\t\tif t>=1 then return Vector3.Clone(b) end\r\n\r\n\t\tlocal ma=Vector3.Magnitude(a)\r\n\t\tlocal mb=Vector3.Magnitude(b)\r\n\t\tif ma<Epsilon or mb<Epsilon then\r\n\t\t\treturn Vector3.Lerp(a,b,t)\r\n\t\tend\r\n\r\n\t\tlocal dot=Vector3.Dot(a,b)/(ma*mb)\r\n\t\tif dot>1-Epsilon then\r\n\t\t\treturn Vector3.Lerp(a,b,t)\r\n\t\telseif dot<-1+Epsilon then\r\n\t\t\tlocal lerpedMagnitude = lerpf (ma, mb, t)\r\n\t\t\tlocal na = I.__div(a,ma)\r\n\t\t\tlocal axis = Vector3.OrthoNormalVector(na)\r\n\t\t\tlocal m=Matrix3x3.New()\r\n\t\t\tMatrix3x3.SetAxisAngle(m,axis,PI*t)\r\n\t\t\tlocal slerped = Matrix3x3.Mul(m,na)\r\n\t\t\tVector3.Mul(slerped,lerpedMagnitude)\r\n\t\t\treturn slerped\r\n\t\telse\r\n\t\t\tlocal lerpedMagnitude = lerpf (ma, mb, t)\r\n\t\t\tlocal axis = Vector3.Cross(a,b)\r\n\t\t\tlocal na = a/ma\r\n\t\t\tVector3.Normalized(axis)\r\n\t\t\tlocal angle=acos(dot)*t\r\n\t\t\tlocal m=Matrix3x3.New()\r\n\t\t\tMatrix3x3.SetAxisAngle(m,axis,angle)\r\n\t\t\tlocal slerped = Matrix3x3.Mul(m,na)\r\n\t\t\tVector3.Mul(slerped,lerpedMagnitude)\r\n\t\t\treturn slerped\r\n\t\tend\r\n\tend\r\n\r\n\tfunction Vector3.Lerp(a,b,t)\r\n\t\treturn Vector3.New(a[1]+(b[1]-a[1])*t\r\n\t\t\t,a[2]+(b[2]-a[2])*t\r\n\t\t\t,a[3]+(b[3]-a[3])*t\r\n\t\t)\r\n\tend\r\n\r\n\tfunction Vector3.Min(a,b)\r\n\t\treturn Vector3.New(min(a[1],b[1])\r\n\t\t\t,min(a[2],b[2])\r\n\t\t\t,min(a[3],b[3]))\r\n\tend\r\n\r\n\tfunction Vector3.Max(a,b)\r\n\t\treturn Vector3.New(max(a[1],b[1])\r\n\t\t\t,max(a[2],b[2])\r\n\t\t\t,max(a[3],b[3]))\r\n\tend\r\n\r\n\tfunction Vector3.MoveTowards(a,b,adv)\r\n\t\tlocal v = I.__sub(b,a)\r\n\t\tlocal m = Vector3.Magnitude(v)\r\n\t\tif m>adv and m~=0 then\r\n\t\t\tVector3.Div(v,m)\r\n\t\t\tVector3.Mul(v,adv)\r\n\t\t\tVector3.Add(v,a)\r\n\t\t\treturn v\r\n\t\tend\r\n\t\treturn Vector3.Clone(b)\r\n\tend\r\n\r\n\tlocal function ClampedMove(a,b,mag)\r\n\t\tlocal delta = b-a\r\n\t\tif delta > 0 then\r\n\t\t\treturn a + min (delta, mag)\r\n\t\telse\r\n\t\t\treturn a - min (-delta, mag)\r\n\t\tend\r\n\tend\r\n\r\n\tfunction Vector3.RotateTowards(a,b,angleMove,mag)\r\n\t\tlocal ma = Vector3.Magnitude(a)\r\n\t\tlocal mb = Vector3.Magnitude (b)\r\n\t\t\r\n\t\tif ma > Epsilon and mb > Epsilon then\r\n\t\t\tlocal na = a / ma\r\n\t\t\tlocal nb = b / mb\r\n\t\t\t\r\n\t\t\tlocal dot = Vector3.Dot(na, nb)\r\n\t\t\tif dot > 1.0 - Epsilon then\r\n\t\t\t\treturn Vector3.MoveTowards (a, b, mag)\r\n\t\t\telseif dot < -1.0 + Epsilon then\r\n\t\t\t\tlocal axis = Vector3.OrthoNormalVector(na)\r\n\t\t\t\tlocal m=Matrix3x3.New()\r\n\t\t\t\tMatrix3x3.SetAxisAngle(m, axis, angleMove)\r\n\t\t\t\tlocal rotated = Matrix3x3.Mul(m,na)\r\n\t\t\t\tVector3.Mul(rotated,ClampedMove(ma, mb, mag))\r\n\t\t\t\treturn rotated\r\n\t\t\telse\r\n\t\t\t\tlocal angle = acos(dot);\r\n\t\t\t\tlocal axis = Vector3.Cross(na, nb)\r\n\t\t\t\tVector3.Normalized(axis)\r\n\t\t\t\tlocal m=Matrix3x3.New()\r\n\t\t\t\tMatrix3x3.SetAxisAngle(m,axis, min(angleMove, angle))\r\n\t\t\t\tlocal rotated = Matrix3x3.Mul(m,na)\r\n\t\t\t\tVector3.Mul(rotated,ClampedMove(ma, mb, mag))\r\n\t\t\t\treturn rotated\r\n\t\t\tend\r\n\t\telse\r\n\t\t\treturn Vector3.MoveTowards (a,b,mag)\r\n\t\tend\r\n\tend\r\n\r\n\tfunction Vector3.Distance(a,b)\r\n\t\ta=Vector3.Clone(a)\r\n\t\tVector3.Sub(a,b)\r\n\t\treturn Vector3.Magnitude(a)\r\n\tend\r\n\r\n\tfunction Vector3.OrthoNormalize(u,v,w)\r\n\t\tVector3.Normalized(u)\r\n\r\n\t\tlocal dot0 = Vector3.Dot(u,v)\r\n\t\tlocal tu=Vector3.Clone(u)\r\n\t\tVector3.Mul(tu,dot0)\r\n\t\tVector3.Sub(v,tu)\r\n\t\tVector3.Normalized(v)\r\n\r\n\t\tif w then\r\n\t\t\tlocal dot1 = Vector3.Dot(v,w)\r\n\t\t\tlocal dot0 = Vector3.Dot(u,w)\r\n\t\t\tlocal tw=I.__mul(u,dot0)\r\n\t\t\tlocal tv=I.__mul(v,dot1)\r\n\t\t\tVector3.Add(tv,tw)\r\n\t\t\tVector3.Sub(w,tv)\r\n\t\t\tVector3.Normalized(w)\r\n\t\tend\r\n\tend\r\n\r\n\tfunction Vector3.Scale(a,b)\r\n\t\treturn Vector3.New(a[1]*b[1],a[2]*b[2],a[3]*b[3])\r\n\tend\r\n\r\n\tfunction I:Scale( self,b )\r\n\t\treturn Vector3.Scale(self,b)\r\n\tend\r\n\r\n\t-- code copy from reflactor of UnityEgnine\r\n\tfunction Vector3.SmoothDamp(current,target,currentVelocity,smoothTime,maxSpeed,deltaTime)\r\n\t\tlocal deltaTime = deltaTime or Time.deltaTime\r\n\t\tlocal maxSpeed = maxSpeed or Infinite\r\n\t\tsmoothTime = max(Epsilon,smoothTime)\r\n\t\tlocal float num = 2 / smoothTime\r\n\t    local float num2 = num * deltaTime\r\n\t    local float num3 = 1 / (((1 + num2) + ((0.48 * num2) * num2)) + (((0.235 * num2) * num2) * num2))\r\n\t    local vector = current - target;\r\n\t    local vector2 = target\r\n\t    local maxLength = maxSpeed * smoothTime\r\n\t    vector = Vector3.ClampMagnitude(vector, maxLength)\r\n\t    target = current - vector\r\n\t    local vector3 = currentVelocity +  vector * deltaTime * num\r\n\t    local newv = currentVelocity -  vector3 * num3 * num\r\n\t    local vector4 = target + (vector + vector3) * num3\r\n\t    if Vector3.Dot(vector2 - current, vector4 - vector2) > 0 then\r\n\t        vector4 = vector2\r\n\t        newv = (vector4 - vector2) / deltaTime\r\n\t    end\r\n\t    currentVelocity:Set(newv.x,newv.y,newv.z)\r\n\t    return vector4,currentVelocity\r\n\tend\r\n\r\n\t-- code copy from reflactor of UnityEgnine\r\n\tfunction Vector3.ClampMagnitude(vector,maxLength)\r\n\t    if Vector3.SqrMagnitude(vector) > (maxLength^2) then\r\n\t        return vector.normalized * maxLength\r\n\t    end\r\n\t    return Vector3.Clone(vector)\r\n\tend\r\n\r\n\tfunction Vector3.Reflect(dir,nml)\r\n\t\tlocal dot=Vector3.Dot(nml,dir)*-2\r\n\t\tlocal v=I.__mul(nml,dot)\r\n\t\tVector3.Add(v,dir)\r\n\t\treturn v\r\n\tend\r\n\r\n\t-- code copy from reflactor of UnityEgnine\r\n\tfunction Vector3.ProjectOnPlane(vector,planeNormal)\r\n\t\treturn vector - Vector3.Project(vector, planeNormal)\r\n\tend\r\n\r\n\t-- code copy from reflactor of UnityEgnine\r\n\tfunction Vector3.Project( vector,normal )\r\n\t\tlocal num = Vector3.Dot(normal, normal)\r\n\t    if num < Epsilon then\r\n\t        return Vector3.zero\r\n\t    end\r\n\t    return (normal * Vector3.Dot(vector, normal)) / num\r\n\tend\r\n\r\n\tsetmetatable(Vector3,Vector3)\r\nend\r\n\r\ndo\r\n\r\n\r\n\tlocal Raw=UnityEngine.Color\r\n\tlocal Color={__typename='Color',__raw=Raw}\r\n\t_G['UnityEngine.Color.Instance']=Color\r\n\tUnityEngine.Color=Color\r\n\tlocal get={}\r\n\tlocal set={}\r\n\r\n\tColor.__index = function(t,k)\r\n\t\tlocal f=rawget(Color,k)\r\n\t\tif f then return f end\r\n\t\tlocal f=rawget(get,k)\r\n\t\tif f then return f(t) end\r\n\t\terror('Not found '..k)\r\n\tend\r\n\r\n\tColor.__newindex = function(t,k,v)\r\n\t\tlocal f=rawget(set,k)\r\n\t\tif f then return f(t,v) end\r\n\t\terror('Not found '..k)\r\n\tend\r\n\r\n\tColor.__tostring = function(self)\r\n\t\treturn string.format('Color(%f,%f,%f,%f)',self[1],self[2],self[3],self[4])\r\n\tend\r\n\r\n\r\n\tfunction Color.New(r,g,b,a)\r\n\t\ta=a or 1\r\n\t\tlocal c={r or 0,g or 0,b or 0,a or 0}\r\n\t\tsetmetatable(c,Color)\r\n\t\treturn c\r\n\tend\r\n\r\n\tfunction Color.__call(t,r,g,b,a)\r\n\t\treturn Color.New(r,g,b,a)\r\n\tend\r\n\r\n\tfunction Color.__add(a,b)\r\n\t\treturn Color.New(a[1]+b[1],a[2]+b[2],a[3]+b[3],a[4]+b[4])\r\n\tend\r\n\r\n\tfunction Color.__sub(a,b)\r\n\t\treturn Color.New(a[1]-b[1],a[2]-b[2],a[3]-b[3],a[4]-b[4])\r\n\tend\r\n\r\n\tfunction Color.__mul( a,b )\r\n\t\tif type(a)=='number' then\r\n\t\t\treturn Color.New(a*b[1],a*b[2],a*b[3],a*b[4])\r\n\t\telseif type(b)=='number' then\r\n\t\t\treturn Color.New(a[1]*b,a[2]*b,a[3]*b,a[4]*b)\r\n\t\telse\r\n\t\t\treturn Color.New(a[1]*b[1],a[2]*b[2],a[3]*b[3],a[4]*b[4])\r\n\t\tend\r\n\tend\r\n\r\n\tfunction Color.__div( a,b )\r\n\t\treturn Color.New(a[1]/b,a[2]/b,a[3]/b,a[4]/b)\r\n\tend\r\n\r\n\tfunction Color.__eq( a,b )\r\n\t\treturn a[1]==b[1] and a[2]==b[2] and a[3]==b[3] and a[4]==b[4]\r\n\tend\r\n\r\n\tlocal function ToLinear(value)\r\n\t\tif value <= 0.04045 then\r\n\t\t\treturn value / 12.92\r\n\t\telseif value < 1.0 then\r\n\t\t\treturn pow((value + 0.055)/1.055, 2.4)\r\n\t\telse\r\n\t\t\treturn pow(value, 2.4)\r\n\t\tend\r\n\tend\r\n\r\n\tlocal function ToGamma(value)\r\n\t\tif value <= 0.0 then\r\n\t\t\treturn 0.0\r\n\t\telseif value <= 0.0031308 then\r\n\t\t\treturn 12.92 * value\r\n\t\telseif value <= 1.0 then\r\n\t\t\treturn 1.055 * pow(value, 0.41666) - 0.055\r\n\t\telse\r\n\t\t\treturn pow(value, 0.41666)\r\n\t\tend\r\n\tend\r\n\r\n\tfunction get.red() return Color.New(1,0,0,1) end\r\n\tfunction get.green() return Color.New(0,1,0,1) end\r\n\tfunction get.blue() return Color.New(0,0,1,1) end\r\n\tfunction get.white() return Color.New(1,1,1,1) end\r\n\tfunction get.black() return Color.New(0,0,0,1) end\r\n\tfunction get.yellow() return Color.New(1, 0.9215686, 0.01568628, 1) end\r\n\tfunction get.cyan() return Color.New(0,1,1,1) end\r\n\tfunction get.magenta() return Color.New(1,0,1,1) end\r\n\tfunction get.gray() return Color.New(0.5,0.5,0.5,1) end\r\n\tfunction get.grey() return Color.New(0.5,0.5,0.5,1) end\r\n\tfunction get.clear() return Color.New(0,0,0,0) end\r\n\tfunction get:grayscale() return (0.299 * self[1]) + (0.587 * self[2]) + (0.114 * self[3]) end\r\n\tfunction get:linear() \r\n\t\treturn Color.New(ToLinear(self[1]),ToLinear(self[2]),ToLinear(self[3]),self[4]) \r\n\tend\r\n\tfunction get:gamma() \r\n\t\treturn Color.New(ToGamma(self[1]),ToGamma(self[2]),ToGamma(self[3]),self[4]) \r\n\tend\r\n\tfunction get:r() return self[1]\tend\r\n\tfunction get:g() return self[2]\tend\r\n\tfunction get:b() return self[3]\tend\r\n\tfunction get:a() return self[4]\tend\r\n\tfunction set:r(v) self[1]=v\tend\r\n\tfunction set:g(v) self[2]=v\tend\r\n\tfunction set:b(v) self[3]=v\tend\r\n\tfunction set:a(v) self[4]=v\tend\r\n\r\n\tfunction Color.Lerp( a,b,t )\r\n\t\tt=clamp(t)\r\n\t\treturn Color.New( lerpf(a[1],b[1],t),lerpf(a[2],b[2],t),lerpf(a[3],b[3],t),lerpf(a[4],b[4],t) )\r\n\tend\r\n\r\n\r\n\tsetmetatable(Color,Color)\r\n\r\nend\r\n\r\ndo\r\n\tlocal Raw=UnityEngine.Vector2\r\n\tlocal Vector2={__typename='Vector2',__raw=Raw}\r\n\t_G['UnityEngine.Vector2.Instance']=Vector2\r\n\tUnityEngine.Vector2=Vector2\r\n\tlocal get={}\r\n\tlocal set={}\r\n\r\n\tVector2.__index = function(t,k)\r\n\t\tlocal f=rawget(Vector2,k)\r\n\t\tif f then return f end\r\n\t\tlocal f=rawget(get,k)\r\n\t\tif f then return f(t) end\r\n\t\terror('Not found '..k)\r\n\tend\r\n\r\n\tVector2.__newindex = function(t,k,v)\r\n\t\tlocal f=rawget(set,k)\r\n\t\tif f then return f(t,v) end\r\n\t\terror('Not found '..k)\r\n\tend\r\n\r\n\tVector2.__tostring = function(self)\r\n\t\treturn string.format('Vector2(%f,%f)',self[1],self[2])\r\n\tend\r\n\r\n\tfunction Vector2.New(x,y)\r\n\t\tlocal v={x or 0,y or 0}\r\n\t\tsetmetatable(v,Vector2)\r\n\t\treturn v\r\n\tend\r\n\r\n\tfunction Vector2.__call(t,x,y)\r\n\t\treturn Vector2.New(x,y)\r\n\tend\r\n\r\n\tfunction Vector2.__add( a,b )\r\n\t\treturn Vector2.New(a[1]+b[1],a[2]+b[2])\r\n\tend\r\n\r\n\tfunction Vector2.__sub( a,b )\r\n\t\treturn Vector2.New(a[1]-b[1],a[2]-b[2])\r\n\tend\r\n\r\n\tfunction Vector2.__eq( a,b )\r\n\t\treturn abs(a[1]-b[1])<Epsilon\r\n\t\t \tand abs(a[2]-b[2])<Epsilon\r\n\tend\r\n\r\n\tfunction Vector2.__mul( a,b )\r\n\t\treturn Vector2.New(a[1]*b,a[2]*b)\r\n\tend\r\n\r\n\tfunction Vector2.__div( a,b )\r\n\t\treturn Vector2.New(a[1]/b,a[2]/b)\r\n\tend\r\n\r\n\tfunction Vector2.__unm( a )\r\n\t\treturn Vector2.New(-a[1],-a[2])\r\n\tend\r\n\r\n\tfunction get.one() return Vector2.New(1,1) end\r\n\tfunction get.zero() return Vector2.New(0,0) end\r\n\tfunction get.up() return Vector2.New(0,1) end\r\n\tfunction get.right() return Vector2.New(1,0) end\r\n\tfunction get:magnitude() return sqrt(self[1]^2+self[2]^2) end\r\n\tfunction get:sqrMagnitude() return self[1]^2+self[2]^2 end\r\n\tfunction get:normalized() \r\n\t\tlocal m = self.magnitude\r\n\t\treturn Vector2.New(self[1]/m,self[2]/m)\r\n\tend\r\n\tfunction get:x() return self[1] end\r\n\tfunction get:y() return self[2] end\r\n\tfunction set:x(v) self[1]=v\tend\r\n\tfunction set:y(v) self[2]=v\tend\r\n\r\n\tinherite(Vector2,Raw)\r\n\r\n\tfunction Vector2.Normalize( v )\r\n\t\tlocal m = Vector2.Magnitude(v)\r\n\t\tv[1],v[2]=v[1]/m,v[2]/m\r\n\tend\r\n\r\n\tfunction Vector2.Magnitude( v )\r\n\t\treturn sqrt(v[1]^2+v[2]^2)\r\n\tend\r\n\r\n\tfunction Vector2:Set( x,y )\r\n\t\tself[1],self[2]=x,y\r\n\tend\r\n\r\n\tfunction Vector2:ToString( )\r\n\t\treturn Vector2.__tostring(self)\r\n\tend\r\n\r\n\tsetmetatable(Vector2,Vector2)\r\nend\r\n\r\ndo\r\n\tlocal Raw=UnityEngine.Vector4\r\n\tlocal Vector4={__typename='Vector4',__raw=Raw}\r\n\t_G['UnityEngine.Vector4.Instance']=Vector4\r\n\tUnityEngine.Vector4=Vector4\r\n\tlocal get={}\r\n\tlocal set={}\r\n\r\n\tVector4.__index = function(t,k)\r\n\t\tlocal f=rawget(Vector4,k)\r\n\t\tif f then return f end\r\n\t\tlocal f=rawget(get,k)\r\n\t\tif f then return f(t) end\r\n\t\terror('Not found '..k)\r\n\tend\r\n\r\n\tVector4.__newindex = function(t,k,v)\r\n\t\tlocal f=rawget(set,k)\r\n\t\tif f then return f(t,v) end\r\n\t\terror('Not found '..k)\r\n\tend\r\n\r\n\tVector4.__tostring = function(self)\r\n\t\treturn string.format('Vector4(%f,%f,%f,%f)',self[1],self[2],self[3],self[4])\r\n\tend\r\n\r\n\tfunction Vector4.New(x,y,z,w)\r\n\t\tlocal v={x or 0,y or 0,z or 0,w or 0}\r\n\t\tsetmetatable(v,Vector4)\r\n\t\treturn v\r\n\tend\r\n\r\n\tfunction Vector4.__call(t,x,y,z,w)\r\n\t\treturn Vector4.New(x,y,z,w)\r\n\tend\r\n\r\n\tfunction Vector4.__add( a,b )\r\n\t\treturn Vector4.New(a[1]+b[1],a[2]+b[2],a[3]+b[3],a[4]+b[4])\r\n\tend\r\n\r\n\tfunction Vector4.__sub( a,b )\r\n\t\treturn Vector4.New(a[1]-b[1],a[2]-b[2],a[3]-b[3],a[4]-b[4])\r\n\tend\r\n\r\n\tfunction Vector4.__eq( a,b )\r\n\t\treturn abs(a[1]-b[1])<Epsilon\r\n\t\t \tand abs(a[2]-b[2])<Epsilon\r\n\t\t \tand abs(a[3]-b[3])<Epsilon\r\n\t\t \tand abs(a[4]-b[4])<Epsilon\r\n\tend\r\n\r\n\tfunction Vector4.__mul( a,b )\r\n\t\treturn Vector4.New(a[1]*b,a[2]*b,a[3]*b,a[4]*b)\r\n\tend\r\n\r\n\tfunction Vector4.__div( a,b )\r\n\t\treturn Vector4.New(a[1]/b,a[2]/b,a[3]/b,a[4]/b)\r\n\tend\r\n\r\n\tfunction Vector4.__unm( a )\r\n\t\treturn Vector4.New(-a[1],-a[2],-a[3],-a[4])\r\n\tend\r\n\r\n\tfunction get.one() return Vector4.New(1,1,1,1) end\r\n\tfunction get.zero() return Vector4.New(0,0,0,0) end\r\n\tfunction get:x() return self[1]\tend\r\n\tfunction get:y() return self[2]\tend\r\n\tfunction get:z() return self[3]\tend\r\n\tfunction get:w() return self[4]\tend\r\n\tfunction get:magnitude() return sqrt(self[1]^2+self[2]^2+self[3]^2+self[4]^2) end\r\n\tfunction get:sqrMagnitude() return self[1]^2+self[2]^2+self[3]^2+self[4]^2 end\r\n\tfunction get:normalized() \r\n\t\tlocal m = self.magnitude\r\n\t\treturn Vector4.New(self[1]/m,self[2]/m,self[3]/m,self[4]/m)\r\n\tend\r\n\tfunction set:x(v) self[1]=v\tend\r\n\tfunction set:y(v) self[2]=v\tend\r\n\tfunction set:z(v) self[3]=v\tend\r\n\tfunction set:w(v) self[4]=v\tend\r\n\r\n\tfunction Vector4:Set( x,y,z,w )\r\n\t\tself[1],self[2],self[3],self[4]=x,y,z,w\r\n\tend\r\n\r\n\tfunction Vector4:ToString( ... )\r\n\t\treturn Vector4.__tostring(self)\r\n\tend\r\n\r\n\tinherite(Vector4,Raw)\r\n\r\n\tsetmetatable(Vector4,Vector4)\r\nend\r\n\r\ndo\r\n\tlocal Raw=UnityEngine.Quaternion\r\n\tlocal Inst=_G['UnityEngine.Quaternion.Instance']\r\n\tlocal Quaternion={__typename='Quaternion',__raw=Raw}\r\n\t_G['UnityEngine.Quaternion.Instance']=Quaternion\r\n\tUnityEngine.Quaternion=Quaternion\r\n\tlocal get={}\r\n\tlocal set={}\r\n\r\n\tQuaternion.__index = function(t,k)\r\n\t\tlocal f=rawget(Quaternion,k)\r\n\t\tif f then return f end\r\n\t\tlocal f=rawget(get,k)\r\n\t\tif f then return f(t) end\r\n\t\terror('Not found '..k)\r\n\tend\r\n\r\n\tQuaternion.__newindex = function(t,k,v)\r\n\t\tlocal f=rawget(set,k)\r\n\t\tif f then return f(t,v) end\r\n\t\terror('Not found '..k)\r\n\tend\r\n\r\n\tQuaternion.__tostring = function(self)\r\n\t\treturn string.format('Quaternion(%f,%f,%f,%f)',self[1],self[2],self[3],self[4])\r\n\tend\r\n\r\n\tQuaternion.__div = function(a,b)\r\n\t\treturn Quaternion.New(a[1]/b,a[2]/b,a[3]/b,a[4]/b)\r\n\tend\r\n\r\n\t-- reflector code\r\n\tQuaternion.__mul = function(a,b,target)\r\n\t\tif getmetatable(b).__typename=='Vector3' then\r\n\t\t\t    local vector=Vector3.New(0,0,0)\r\n\t\t\t    local num = a[1] * 2\r\n\t\t\t    local num2 = a[2] * 2\r\n\t\t\t    local num3 = a[3] * 2\r\n\t\t\t    local num4 = a[1] * num\r\n\t\t\t    local num5 = a[2] * num2\r\n\t\t\t    local num6 = a[3] * num3\r\n\t\t\t    local num7 = a[1] * num2\r\n\t\t\t    local num8 = a[1] * num3\r\n\t\t\t    local num9 = a[2] * num3\r\n\t\t\t    local num10 = a.w * num\r\n\t\t\t    local num11 = a.w * num2\r\n\t\t\t    local num12 = a.w * num3\r\n\t\t\t    vector[1] = (((1 - (num5 + num6)) * b[1]) + ((num7 - num12) * b[2])) + ((num8 + num11) * b[3])\r\n\t\t\t    vector[2] = (((num7 + num12) * b[1]) + ((1 - (num4 + num6)) * b[2])) + ((num9 - num10) * b[3])\r\n\t\t\t    vector[3] = (((num8 - num11) * b[1]) + ((num9 + num10) * b[2])) + ((1 - (num4 + num5)) * b[3])\r\n\t\t\t    return vector\r\n\t\telse\r\n\t\t\tlocal x,y,z,w =\r\n\t\t\t\t(((a[4] * b[1]) + (a[1] * b[4])) + (a[2] * b[3])) - (a[3] * b[2]),\r\n\t\t\t \t(((a[4] * b[2]) + (a[2] * b[4])) + (a[3] * b[1])) - (a[1] * b[3]),\r\n\t\t\t \t(((a[4] * b[3]) + (a[3] * b[4])) + (a[1] * b[2])) - (a[2] * b[1]),\r\n\t\t\t \t(((a[4] * b[4]) - (a[1] * b[1])) - (a[2] * b[2])) - (a[3] * b[3])\r\n\r\n\t\t\t if target then\r\n\t\t\t \ttarget[1],target[2],target[3],target[4]=x,y,z,w\r\n\t\t\t else\r\n\t\t\t \treturn Quaternion.New(x,y,z,w)\r\n\t\t\t end\r\n\t\tend\r\n\tend\r\n\r\n\tfunction Quaternion.Mul(a,b)\r\n\t\treturn Quaternion.__mul(a,b,a)\r\n\tend\r\n\r\n\t-- reflector code\r\n\tQuaternion.__eq = function(a,b)\r\n\t\treturn Quaternion.Dot(a,b)>0.999999\r\n\tend\r\n\r\n\r\n\tfunction Quaternion.New(x,y,z,w)\r\n\t\tlocal q={x or 0,y or 0,z or 0,w or 0}\r\n\t\tsetmetatable(q,Quaternion)\r\n\t\treturn q\r\n\tend\r\n\r\n\tfunction Quaternion.__call(t,x,y,z,w)\r\n\t\treturn Quaternion.New(x,y,z,w)\r\n\tend\r\n\r\n\tfunction get.identity() return Quaternion.New(0,0,0,1)\tend\r\n\tfunction get:x() return self[1]\tend\r\n\tfunction get:y() return self[2]\tend\r\n\tfunction get:z() return self[3]\tend\r\n\tfunction get:w() return self[4]\tend\r\n\tfunction set:x(v) self[1]=v\tend\r\n\tfunction set:y(v) self[2]=v\tend\r\n\tfunction set:z(v) self[3]=v\tend\r\n\tfunction set:w(v) self[4]=v\tend\r\n\r\n\tfunction get:eulerAngles() return Inst.eulerAngles[1](self) end\r\n\tfunction set:eulerAngles(v) Inst.eulerAngles[2](self,v) end\r\n\r\n\tfunction Quaternion:Set(x,y,z,w)\r\n\t\tself[1],self[2],self[3],self[4]=x,y,z,w\r\n\tend\r\n\r\n\tfunction Quaternion:Clone()\r\n\t\treturn Quaternion.New(self[1],self[2],self[3],self[4])\r\n\tend\r\n\r\n\tfunction Quaternion:ToAngleAxis()\r\n\t\tlocal angle = acos(self[4])*2\r\n\t\tif abs(angle-0)<Epsilon then\r\n\t\t\treturn angle,Vector3.New(1,0,0)\r\n\t\tend\r\n\t\tlocal div = 1/sqrt(1-self[4]^2)\r\n\t\treturn angle,Vector3.New(self[1]*div,self[2]*div,self[3]*div)\r\n\tend\r\n\r\n\t--TODO\r\n\tfunction Quaternion:SetFromToRotation(from,to)\r\n\t\tInst.SetFromToRotation(self,from,to)\r\n\tend\r\n\r\n\t--TODO\r\n\tfunction Quaternion:SetLookRotation(view,up)\r\n\t\tup = up or Vector3.up\r\n\t\tInst.SetLookRotation(self,view,up)\r\n\tend\r\n\r\n\tinherite(Quaternion,Raw)\r\n\r\n\tfunction Quaternion.Euler( x,y,z )\r\n\t\tif type(x)=='table' then\r\n\t\t\tx,y,z=x[1],x[2],x[3]\r\n\t\tend\r\n\t\tx,y,z=x*ToRad*0.5,y*ToRad*0.5,z*ToRad*0.5\r\n\r\n\t\tlocal cX=cos(x)\r\n\t\tlocal sX=sin(x)\r\n\t\tlocal cY=cos(y)\r\n\t\tlocal sY=sin(y)\r\n\t\tlocal cZ=cos(z)\r\n\t\tlocal sZ=sin(z)\r\n\t\t\r\n\t\tlocal qX=Quaternion.New(sX, 0, 0, cX)\r\n\t\tlocal qY=Quaternion.New(0, sY, 0, cY)\r\n\t\tlocal qZ=Quaternion.New(0, 0.0, sZ, cZ)\r\n\t\t\r\n\t\tQuaternion.Mul(qY,qX)\r\n\t\tQuaternion.Mul(qY,qZ)\r\n\t\treturn qY\r\n\tend\r\n\r\n\t-- code from reflector unityengine\r\n\tfunction Quaternion.Dot( a,b )\r\n\t\treturn a[1] * b[1] + a[2] * b[2] + a[3] * b[3] + a[4] * b[4]\r\n\tend\r\n\r\n\tfunction Quaternion.Normalize(q)\r\n\t\tq=Quaternion.Clone(q)\r\n\t\tlocal m=Quaternion.Dot(q,q)\r\n\t\tq[1],q[2],q[3],q[4]=q[1]/m,q[2]/m,q[3]/m,q[4]/m\r\n\t\treturn q\r\n\tend\r\n\r\n\tfunction Quaternion.Lerp( q1,q2,t )\r\n\t\tlocal tmpQuat=Quaternion.New(0,0,0,1)\r\n\t\tif Quaternion.Dot(q1, q2) < 0 then\r\n\t\t\ttmpQuat:Set(q1[1] + t * (-q2[1] - q1[1]),\r\n\t\t\t            q1[2] + t * (-q2[2] - q1[2]),\r\n\t\t\t            q1[3] + t * (-q2[3] - q1[3]),\r\n\t\t\t            q1[4] + t * (-q2[4] - q1[4]))\r\n\t\telse\r\n\t\t\ttmpQuat:Set(q1[1] + t * (q2[1] - q1[1]),\r\n\t\t\t            q1[2] + t * (q2[2] - q1[2]),\r\n\t\t\t            q1[3] + t * (q2[3] - q1[3]),\r\n\t\t\t            q1[4] + t * (q2[4] - q1[4]))\r\n\t\tend\r\n\t\treturn Quaternion.Normalize(tmpQuat)\r\n\tend\r\n\r\n\t-- code from unityengine\r\n\tfunction Quaternion.Slerp( q1,q2,t )\r\n\t\tt=clamp(t)\r\n\t\tlocal dot = Quaternion.Dot( q1, q2 )\r\n\t\tlocal tmpQuat=Quaternion.New(0,0,0,1)\r\n\t\tif dot < 0 then\r\n\t\t\tdot = -dot\r\n\t\t\ttmpQuat:Set( -q2[1],-q2[2],-q2[3],-q2[4] )\r\n\t\telse\r\n\t\t\ttmpQuat = q2\r\n\t\tend\r\n\r\n\t\t\r\n\t\tif dot < 0.95 then\r\n\t\t\tlocal angle = acos(dot)\r\n\t\t\tlocal sinadiv, sinat, sinaomt\r\n\t\t\tsinadiv = 1/sin(angle)\r\n\t\t\tsinat   = sin(angle*t)\r\n\t\t\tsinaomt = sin(angle*(1-t))\r\n\t\t\ttmpQuat:Set( (q1[1]*sinaomt+tmpQuat[1]*sinat)*sinadiv,\r\n\t\t\t\t     (q1[2]*sinaomt+tmpQuat[2]*sinat)*sinadiv,\r\n\t\t\t\t     (q1[3]*sinaomt+tmpQuat[3]*sinat)*sinadiv, \r\n\t\t\t\t     (q1[4]*sinaomt+tmpQuat[4]*sinat)*sinadiv  )\r\n\t\t\treturn tmpQuat\r\n\t\telse\r\n\t\t\treturn Quaternion.Lerp(q1,tmpQuat,t)\r\n\t\tend\r\n\tend\r\n\r\n\tsetmetatable(Quaternion,Quaternion)\r\nend\r\n\r\n";

		public static void reg(IntPtr l)
		{
			LuaState.get(l).doString(LuaValueType.script, "ValueTypeScript");
		}
	}
}
